"""
app/utils/script_generator/sensor_placement.py
==============================================
Generates a standalone, runnable Python example script for the Sensor
Placement tab. The script reproduces threat-zone generation + sensor
optimization and saves an interactive Folium map.
"""

from __future__ import annotations

import textwrap
from datetime import datetime

from .threat_zones import _slug, _single_source_block, _multi_source_block


def generate_sensor_script(
    *,
    chemical: str,
    molecular_weight: float,
    release_type: str,
    source_term_mode: str,
    lat: float,
    lon: float,
    release_rate: float,
    tank_height: float,
    duration_minutes: float,
    mass_released_kg: float,
    terrain_roughness: str,
    receptor_height_m: float,
    weather_mode: str,
    wind_speed: float,
    wind_dir: float,
    temperature_c: float,
    humidity_pct: float,
    cloud_cover_pct: float,
    timezone_offset_hrs: float,
    datetime_mode: str,
    specific_datetime: str | None,
    aegl_thresholds: dict,
    x_max: int,
    y_max: int,
    sensor_strategy: str,
    sensor_num: int,
    sensor_detection_range_m: float,
    sensor_min_spacing_m: float,
    sensor_cost_per_sensor: float,
    sensor_population_raster_path: str,
    multi_sources: list[dict] | None = None,
) -> str:
    """Return the full text of a standalone Sensor Placement Python script."""

    now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    chem_slug = _slug(chemical)
    rel_type_label = "Multi-Source" if release_type == "multi" else "Single Source"

    if weather_mode == "auto":
        weather_block = textwrap.dedent("""\
            weather = get_weather(
                latitude=SOURCE_LAT,
                longitude=SOURCE_LON,
                source="open_meteo",
            )
            print(f"  Wind speed : {weather['wind_speed']:.2f} m/s")
            print(f"  Wind dir   : {weather['wind_dir']:.1f} deg")
            print(f"  Temperature: {weather['temperature_K'] - 273.15:.1f} C")
        """)
    else:
        weather_block = textwrap.dedent("""\
            weather = {
                "wind_speed"    : WIND_SPEED,
                "wind_dir"      : WIND_DIRECTION,
                "temperature_K" : TEMPERATURE_C + 273.15,
                "humidity"      : HUMIDITY / 100.0,
                "cloud_cover"   : CLOUD_COVER / 100.0,
                "source"        : "manual",
            }
        """)

    if datetime_mode == "specific" and specific_datetime:
        dt_block = f'simulation_datetime = datetime.fromisoformat("{specific_datetime}")'
    else:
        dt_block = "simulation_datetime = datetime.now()"

    if release_type == "single":
        dispersion_block = _single_source_block(source_term_mode)
    else:
        dispersion_block = _multi_source_block(source_term_mode, multi_sources or [])

    if release_type == "multi" and multi_sources:
        lines = ["RELEASE_SOURCES = ["]
        for i, src in enumerate(multi_sources):
            lines.append(f"    {{  # Source {i + 1}")
            lines.append(f'        "lat"   : {src["lat"]},')
            lines.append(f'        "lon"   : {src["lon"]},')
            lines.append(f'        "name"  : "{src.get("name", f"Source {i + 1}")}",')
            lines.append(f'        "height": {src["height"]},')
            lines.append(f'        "rate"  : {src["rate"]},')
            lines.append("    },")
        lines.append("]")
        multi_source_cfg = "\n".join(lines)
    else:
        multi_source_cfg = "# No additional sources (single-source mode)"

    weather_import = (
        "from pyeldqm.core.meteorology.realtime_weather import get_weather"
        if weather_mode == "auto"
        else "# from pyeldqm.core.meteorology.realtime_weather import get_weather"
    )

    raster_repr = repr(sensor_population_raster_path) if sensor_population_raster_path else repr("")

    def _d(s: str) -> str:
        return textwrap.dedent(s).lstrip("\n")

    s_doc = _d(f"""\
        \"\"\"
        Sensor Placement Optimization — Auto-Generated Example
        ======================================================
        Generated by pyELDQM Dash app on {now_str}

        Scenario   : {rel_type_label} Release
        Chemical   : {chemical}
        Location   : {lat}, {lon}
        Weather    : {"Real-time (Open-Meteo)" if weather_mode == "auto" else "Manual"}

        Run from any directory:
            python {chem_slug}_sensor_placement.py

        Outputs saved to ./outputs/sensor_placement/
        - {chem_slug}_sensor_map_<ts>.html
        \"\"\"
    """)

    s_imports = _d(f"""\
        from pathlib import Path
        from datetime import datetime
        import webbrowser
        import numpy as np
        import folium

        from pyeldqm.core.dispersion_models.gaussian_model import (
            calculate_gaussian_dispersion,
            multi_source_concentration,
        )
        from pyeldqm.core.meteorology.stability import get_stability_class
        from pyeldqm.core.meteorology.wind_profile import wind_speed as wind_profile
        {weather_import}
        from pyeldqm.core.utils.features import setup_computational_grid
        from pyeldqm.core.utils.zone_extraction import extract_zones
        from pyeldqm.core.visualization import (
            add_zone_polygons,
            ensure_layer_control,
            fit_map_to_polygons,
        )
        from pyeldqm.core.utils.sensor_optimization import SensorPlacementOptimizer
    """)

    s_cfg = _d(f"""\
        CHEMICAL_NAME       = {chemical!r}
        MOLECULAR_WEIGHT    = {molecular_weight}
        SOURCE_LAT          = {lat}
        SOURCE_LON          = {lon}
        TIMEZONE_OFFSET_HRS = {timezone_offset_hrs}

        RELEASE_TYPE        = {release_type!r}
        SOURCE_TERM_MODE    = {source_term_mode!r}
        RELEASE_RATE        = {release_rate}
        TANK_HEIGHT         = {tank_height}
        DURATION_MINUTES    = {duration_minutes}
        MASS_RELEASED_KG    = {mass_released_kg}
        TERRAIN_ROUGHNESS   = {terrain_roughness!r}
        RECEPTOR_HEIGHT_M   = {receptor_height_m}

        WEATHER_MODE        = {weather_mode!r}
        WIND_SPEED          = {wind_speed}
        WIND_DIRECTION      = {wind_dir}
        TEMPERATURE_C       = {temperature_c}
        HUMIDITY            = {humidity_pct}
        CLOUD_COVER         = {cloud_cover_pct}

        AEGL_THRESHOLDS = {aegl_thresholds}
        X_MAX = {x_max}
        Y_MAX = {y_max}

        SENSOR_STRATEGY = {sensor_strategy!r}
        SENSOR_NUM = {sensor_num}
        SENSOR_DETECTION_RANGE_M = {sensor_detection_range_m}
        SENSOR_MIN_SPACING_M = {sensor_min_spacing_m}
        SENSOR_COST_PER_SENSOR = {sensor_cost_per_sensor}
        SENSOR_POP_RASTER_PATH = {raster_repr}

        {multi_source_cfg}
    """)

    s_main = _d(f"""\
        print("Running Sensor Placement optimization...")
        {dt_block}
        print(f"Simulation datetime: {{simulation_datetime.isoformat()}}")

        {weather_block}

        stability_class = get_stability_class(
            wind_speed=weather["wind_speed"],
            cloud_cover=weather["cloud_cover"],
            daytime=6 <= simulation_datetime.hour <= 18,
            urban=(TERRAIN_ROUGHNESS.upper() == "URBAN"),
        )

        u_ref = wind_profile(
            weather["wind_speed"],
            z=TANK_HEIGHT,
            z_ref=10,
            p=0.33 if TERRAIN_ROUGHNESS.upper() == "URBAN" else 0.15,
        )

        X, Y, _, _ = setup_computational_grid(
            x_max=X_MAX, y_max=Y_MAX, source_height=TANK_HEIGHT,
            source_lat=SOURCE_LAT, source_lon=SOURCE_LON,
            wind_direction=weather["wind_dir"],
        )

        RELEASE_DURATION_S = DURATION_MINUTES * 60.0
        TOTAL_MASS_G = MASS_RELEASED_KG * 1000.0

        {dispersion_block}

        threat_zones = extract_zones(
            X, Y, concentration, AEGL_THRESHOLDS,
            SOURCE_LAT, SOURCE_LON, wind_dir=weather["wind_dir"],
        )

        population_engine = None
        if SENSOR_POP_RASTER_PATH and str(SENSOR_POP_RASTER_PATH).strip():
            try:
                from pyeldqm.core.population import SensorPopulationEngine
                population_engine = SensorPopulationEngine(str(SENSOR_POP_RASTER_PATH).strip())
            except Exception as pop_err:
                print(f"Population engine unavailable: {{pop_err}}")

        optimizer = SensorPlacementOptimizer(
            population_engine=population_engine,
            config={{
                "detection_range_m": SENSOR_DETECTION_RANGE_M,
                "min_sensor_spacing_m": SENSOR_MIN_SPACING_M,
                "cost_per_sensor": SENSOR_COST_PER_SENSOR,
            }},
        )

        sensors = optimizer.optimize_sensor_placement(
            threat_zones, SOURCE_LAT, SOURCE_LON,
            num_sensors=SENSOR_NUM,
            strategy=SENSOR_STRATEGY,
            wind_direction=weather["wind_dir"],
        )

        metrics = optimizer.calculate_coverage_metrics(sensors, threat_zones)
        coverage_area = metrics.get("coverage_area_km2", 0.0)
        total_cost = SENSOR_COST_PER_SENSOR * len(sensors)

        print(f"Sensors deployed: {{len(sensors)}}")
        print(f"Coverage area   : {{coverage_area:.2f}} km²")
        print(f"Estimated cost  : ${{total_cost:,.0f}}")

        m = folium.Map(location=[SOURCE_LAT, SOURCE_LON], zoom_start=13, tiles="OpenStreetMap")
        folium.TileLayer(
            tiles="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{{z}}/{{y}}/{{x}}",
            attr="Esri", name="Satellite", overlay=False, control=True,
        ).add_to(m)

        folium.Marker([SOURCE_LAT, SOURCE_LON], tooltip="Release Source",
                      icon=folium.Icon(color="red", icon="warning-sign")).add_to(m)

        add_zone_polygons(
            m,
            {{k: v for k, v in threat_zones.items() if k in ["AEGL-1", "AEGL-2", "AEGL-3"]}},
            thresholds_context={{"AEGL": AEGL_THRESHOLDS}},
            name_prefix=None,
        )
        fit_map_to_polygons(m, threat_zones.values())

        sensor_fg = folium.FeatureGroup(name="Sensor Network", show=True)
        for i, sensor in enumerate(sensors, start=1):
            slat = sensor.get("latitude", SOURCE_LAT)
            slon = sensor.get("longitude", SOURCE_LON)
            spriority = sensor.get("priority", "medium").capitalize()

            folium.CircleMarker(
                [slat, slon],
                radius=8,
                color="#FF6B35",
                fill=True,
                fill_color="#FF6B35",
                fill_opacity=0.8,
                tooltip=f"Sensor {{i}} (Priority: {{spriority}})",
            ).add_to(sensor_fg)

            folium.Circle(
                [slat, slon],
                radius=SENSOR_DETECTION_RANGE_M,
                color="#FF6B35",
                fill=True,
                fill_opacity=0.1,
                weight=1,
                tooltip=f"Sensor {{i}} detection range",
            ).add_to(sensor_fg)
        sensor_fg.add_to(m)

        ensure_layer_control(m)

        _out_dir = Path.cwd() / "outputs" / "sensor_placement"
        _out_dir.mkdir(parents=True, exist_ok=True)
        _ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        _map_path = _out_dir / f"{chem_slug}_sensor_map_{{_ts}}.html"
        m.save(str(_map_path))

        print(f"Map saved to: {{_map_path}}")
        webbrowser.open(_map_path.as_uri())
    """)

    return s_doc + "\n" + s_imports + "\n" + s_cfg + "\n" + s_main
