"""
app/utils/script_generator/route_optimization.py
================================================
Generates a standalone, runnable Python example script for the Emergency
Routes tab. The script reproduces threat-zone generation + road-risk
classification + shelter ranking and saves an interactive Folium map.
"""

from __future__ import annotations

import textwrap
from datetime import datetime

from .threat_zones import _slug, _single_source_block, _multi_source_block


def generate_route_script(
    *,
    chemical: str,
    molecular_weight: float,
    release_type: str,
    source_term_mode: str,
    lat: float,
    lon: float,
    release_rate: float,
    tank_height: float,
    duration_minutes: float,
    mass_released_kg: float,
    terrain_roughness: str,
    receptor_height_m: float,
    weather_mode: str,
    wind_speed: float,
    wind_dir: float,
    temperature_c: float,
    humidity_pct: float,
    cloud_cover_pct: float,
    timezone_offset_hrs: float,
    datetime_mode: str,
    specific_datetime: str | None,
    aegl_thresholds: dict,
    x_max: int,
    y_max: int,
    route_radius_m: float,
    route_proximity_buffer_m: float,
    show_unsafe_roads: bool,
    shelters: list[dict],
    multi_sources: list[dict] | None = None,
) -> str:
    """Return the full text of a standalone Emergency Routes Python script."""

    now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    chem_slug = _slug(chemical)
    rel_type_label = "Multi-Source" if release_type == "multi" else "Single Source"

    if weather_mode == "auto":
        weather_block = textwrap.dedent("""\
            weather = get_weather(
                latitude=SOURCE_LAT,
                longitude=SOURCE_LON,
                source="open_meteo",
            )
            print(f"  Wind speed : {weather['wind_speed']:.2f} m/s")
            print(f"  Wind dir   : {weather['wind_dir']:.1f} deg")
            print(f"  Temperature: {weather['temperature_K'] - 273.15:.1f} C")
        """)
    else:
        weather_block = textwrap.dedent("""\
            weather = {
                "wind_speed"    : WIND_SPEED,
                "wind_dir"      : WIND_DIRECTION,
                "temperature_K" : TEMPERATURE_C + 273.15,
                "humidity"      : HUMIDITY / 100.0,
                "cloud_cover"   : CLOUD_COVER / 100.0,
                "source"        : "manual",
            }
        """)

    if datetime_mode == "specific" and specific_datetime:
        dt_block = f'simulation_datetime = datetime.fromisoformat("{specific_datetime}")'
    else:
        dt_block = "simulation_datetime = datetime.now()"

    if release_type == "single":
        dispersion_block = _single_source_block(source_term_mode)
    else:
        dispersion_block = _multi_source_block(source_term_mode, multi_sources or [])

    if release_type == "multi" and multi_sources:
        lines = ["RELEASE_SOURCES = ["]
        for i, src in enumerate(multi_sources):
            lines.append(f"    {{  # Source {i + 1}")
            lines.append(f'        "lat"   : {src["lat"]},')
            lines.append(f'        "lon"   : {src["lon"]},')
            lines.append(f'        "name"  : "{src.get("name", f"Source {i + 1}")}",')
            lines.append(f'        "height": {src["height"]},')
            lines.append(f'        "rate"  : {src["rate"]},')
            lines.append("    },")
        lines.append("]")
        multi_source_cfg = "\n".join(lines)
    else:
        multi_source_cfg = "# No additional sources (single-source mode)"

    shelter_lines = ["SHELTERS = ["]
    for i, s in enumerate(shelters or []):
        shelter_lines.append(f"    {{  # Shelter {i + 1}")
        shelter_lines.append(f'        "name": "{s.get("name", f"Shelter {i + 1}")}",')
        shelter_lines.append(f'        "lat" : {s.get("lat")},')
        shelter_lines.append(f'        "lon" : {s.get("lon")},')
        shelter_lines.append("    },")
    shelter_lines.append("]")
    shelters_cfg = "\n".join(shelter_lines)

    weather_import = (
        "from pyeldqm.core.meteorology.realtime_weather import get_weather"
        if weather_mode == "auto"
        else "# from pyeldqm.core.meteorology.realtime_weather import get_weather"
    )

    def _d(s: str) -> str:
        return textwrap.dedent(s).lstrip("\n")

    s_doc = _d(f"""\
        \"\"\"
        Emergency Routes Optimization â€” Auto-Generated Example
        ======================================================
        Generated by pyELDQM Dash app on {now_str}

        Scenario   : {rel_type_label} Release
        Chemical   : {chemical}
        Location   : {lat}, {lon}
        Weather    : {"Real-time (Open-Meteo)" if weather_mode == "auto" else "Manual"}

        Run from any directory:
            python {chem_slug}_route_optimization.py

        Outputs saved to ./outputs/route_optimization/
        - {chem_slug}_route_map_<ts>.html
        \"\"\"
    """)

    s_imports = _d(f"""\
        from pathlib import Path
        from datetime import datetime
        import webbrowser
        import numpy as np
        import folium

        from pyeldqm.core.dispersion_models.gaussian_model import (
            calculate_gaussian_dispersion,
            multi_source_concentration,
        )
        from pyeldqm.core.meteorology.stability import get_stability_class
        from pyeldqm.core.meteorology.wind_profile import wind_speed as wind_profile
        {weather_import}
        from pyeldqm.core.utils.features import setup_computational_grid
        from pyeldqm.core.utils.zone_extraction import extract_zones
        from pyeldqm.core.visualization import (
            add_zone_polygons,
            ensure_layer_control,
            fit_map_to_polygons,
        )
        from pyeldqm.core.evacuation import (
            build_road_graph,
            classify_edges_with_risk,
            rank_shelters,
        )
    """)

    s_cfg = _d(f"""\
        CHEMICAL_NAME       = {chemical!r}
        MOLECULAR_WEIGHT    = {molecular_weight}
        SOURCE_LAT          = {lat}
        SOURCE_LON          = {lon}
        TIMEZONE_OFFSET_HRS = {timezone_offset_hrs}

        RELEASE_TYPE        = {release_type!r}
        SOURCE_TERM_MODE    = {source_term_mode!r}
        RELEASE_RATE        = {release_rate}
        TANK_HEIGHT         = {tank_height}
        DURATION_MINUTES    = {duration_minutes}
        MASS_RELEASED_KG    = {mass_released_kg}
        TERRAIN_ROUGHNESS   = {terrain_roughness!r}
        RECEPTOR_HEIGHT_M   = {receptor_height_m}

        WEATHER_MODE        = {weather_mode!r}
        WIND_SPEED          = {wind_speed}
        WIND_DIRECTION      = {wind_dir}
        TEMPERATURE_C       = {temperature_c}
        HUMIDITY            = {humidity_pct}
        CLOUD_COVER         = {cloud_cover_pct}

        AEGL_THRESHOLDS = {aegl_thresholds}
        X_MAX = {x_max}
        Y_MAX = {y_max}

        ROUTE_RADIUS_M = {route_radius_m}
        ROUTE_BUFFER_M = {route_proximity_buffer_m}
        SHOW_UNSAFE_ROADS = {show_unsafe_roads}

        {multi_source_cfg}

        {shelters_cfg}
    """)

    s_main = _d(f"""\
        def _path_length_m(G, path_nodes):
            if not path_nodes or len(path_nodes) < 2:
                return 0.0
            total = 0.0
            for u, v in zip(path_nodes[:-1], path_nodes[1:]):
                edge_data = G.get_edge_data(u, v)
                if not edge_data:
                    continue
                lengths = [float(attrs.get("length", 0.0)) for _, attrs in edge_data.items()]
                if lengths:
                    total += min(lengths)
            return total

        print("Running Emergency Routes simulation...")
        {dt_block}
        print(f"Simulation datetime: {{simulation_datetime.isoformat()}}")

        {weather_block}

        stability_class = get_stability_class(
            wind_speed=weather["wind_speed"],
            cloud_cover=weather["cloud_cover"],
            daytime=6 <= simulation_datetime.hour <= 18,
            urban=(TERRAIN_ROUGHNESS.upper() == "URBAN"),
        )

        u_ref = wind_profile(
            weather["wind_speed"],
            z=TANK_HEIGHT,
            z_ref=10,
            p=0.33 if TERRAIN_ROUGHNESS.upper() == "URBAN" else 0.15,
        )

        X, Y, _, _ = setup_computational_grid(
            x_max=X_MAX, y_max=Y_MAX, source_height=TANK_HEIGHT,
            source_lat=SOURCE_LAT, source_lon=SOURCE_LON,
            wind_direction=weather["wind_dir"],
        )

        RELEASE_DURATION_S = DURATION_MINUTES * 60.0
        TOTAL_MASS_G = MASS_RELEASED_KG * 1000.0

        {dispersion_block}

        threat_zones = extract_zones(
            X, Y, concentration, AEGL_THRESHOLDS,
            SOURCE_LAT, SOURCE_LON, wind_dir=weather["wind_dir"],
        )

        m = folium.Map(location=[SOURCE_LAT, SOURCE_LON], zoom_start=13, tiles="OpenStreetMap")
        folium.TileLayer(
            tiles="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{{z}}/{{y}}/{{x}}",
            attr="Esri", name="Satellite", overlay=False, control=True,
        ).add_to(m)

        folium.Marker([SOURCE_LAT, SOURCE_LON], tooltip="Source",
                      icon=folium.Icon(color="red", icon="warning-sign")).add_to(m)

        add_zone_polygons(
            m,
            {{k: v for k, v in threat_zones.items() if k in ["AEGL-1", "AEGL-2", "AEGL-3"]}},
            thresholds_context={{"AEGL": AEGL_THRESHOLDS}},
            name_prefix=None,
        )
        fit_map_to_polygons(m, threat_zones.values())

        G = build_road_graph(SOURCE_LAT, SOURCE_LON, ROUTE_RADIUS_M)
        safe_gdf, unsafe_gdf = classify_edges_with_risk(G, threat_zones, proximity_buffer_m=ROUTE_BUFFER_M)

        shelter_points = [(s["lat"], s["lon"]) for s in SHELTERS]
        ranking = rank_shelters(G, (SOURCE_LAT, SOURCE_LON), shelter_points)
        best = next((r for r in ranking if "path" in r), None)

        if best:
            best_dist_m = _path_length_m(G, best.get("path", []))
            print(f"Best shelter distance: {{best_dist_m / 1000:.2f}} km")

        if len(safe_gdf) > 0:
            for _, row in safe_gdf.iterrows():
                geom = row.geometry
                if geom is None:
                    continue
                coords = [(lat, lon) for lon, lat in geom.coords]
                folium.PolyLine(coords, color="#00FC0D", weight=4, opacity=0.95).add_to(m)

        if SHOW_UNSAFE_ROADS and len(unsafe_gdf) > 0:
            for _, row in unsafe_gdf.iterrows():
                geom = row.geometry
                if geom is None:
                    continue
                coords = [(lat, lon) for lon, lat in geom.coords]
                folium.PolyLine(coords, color="#FF0000", weight=4, opacity=0.25).add_to(m)

        if best and best.get("path"):
            route_coords = [(G.nodes[n]["y"], G.nodes[n]["x"]) for n in best["path"] if n in G.nodes]
            if route_coords:
                folium.PolyLine(route_coords, color="#0066FF", weight=6, opacity=1.0).add_to(m)

        for s in SHELTERS:
            is_best = best and abs(s["lat"] - best.get("lat", -999)) < 1e-9 and abs(s["lon"] - best.get("lon", -999)) < 1e-9
            folium.Marker(
                [s["lat"], s["lon"]],
                tooltip=f"ðŸ† RECOMMENDED: {{s['name']}}" if is_best else s["name"],
                icon=folium.Icon(color="green" if is_best else "blue", icon="home" if is_best else "map-marker"),
            ).add_to(m)

        ensure_layer_control(m)

        _out_dir = Path.cwd() / "outputs" / "route_optimization"
        _out_dir.mkdir(parents=True, exist_ok=True)
        _ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        _map_path = _out_dir / f"{chem_slug}_route_map_{{_ts}}.html"
        m.save(str(_map_path))

        print(f"Map saved to: {{_map_path}}")
        print(f"Road segments classified: {{len(safe_gdf)}} safe, {{len(unsafe_gdf)}} unsafe")
        webbrowser.open(_map_path.as_uri())
    """)

    return s_doc + "\n" + s_imports + "\n" + s_cfg + "\n" + s_main
